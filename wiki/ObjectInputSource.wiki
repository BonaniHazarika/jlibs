#summary Creating XML using SAX

Consider `Company` class containing array of `Employee`;

{{{
class Company{
    String name;
    Employee employees[];

    Company(String name, Employee... employees){
        this.name = name;
        this.employees = employees;
    }
}

class Employee{
    String id;
    String name;
    String email;
    int age;

    Employee(String id, String name, String email, int age){
        this.id = id;
        this.name = name;
        this.email = email;
        this.age = age;
    }
}
}}}

*ObjectInputSource:*

This is an extension of `org.xml.sax.InputSource` with single abstract method:
{{{
protected abstract void write(E obj) throws SAXException;
}}}

`InputSource` wraps `systemID` or `OutputStream` or `Reader` which is source of xml;<br>
Similarly, `ObjectInputSource` wraps a java object, which is the source of xml:
{{{
new ObjectInputSource<E>(E obj)
}}}

It is job of its subclass to override `write(E obj)` and fire SAX events.

To help subclasses, it contains methods to generate SAX events like:<br>
    `startElement(String name)`<br>
    `addAttribute(String name, String value)`<br>
    `endElement(String name)`<br>
    etc.

Let us write an implementation of `ObjectInputSource` for `Company`;

{{{
import jlibs.xml.sax.ObjectInputSource;
import org.xml.sax.SAXException;

class CompanyInputSource extends ObjectInputSource<Company>{
    public CompanyInputSource(Company company){
        super(company);
    }

    @Override
    protected void write(Company company) throws SAXException{
        startElement("company");
        addAttribute("name", company.name);
        for(Employee emp: company.employees){
            startElement("employee");
            addAttribute("id", emp.id);
            addAttribute("age", ""+emp.age);
            addElement("name", emp.name);
            addElement("email", emp.email);
            endElement("employee");
        }
        endElement("company");
    }
}
}}}

*Creating XML:*

To create XML, now we can do the following:

{{{
import javax.xml.transform.TransformerException;

public static void main(String[] args) throws TransformerException, XMLStreamException{
    Employee scott = new Employee("1", "scott", "scott@gmail.com", 20);
    Employee alice = new Employee("2", "alice", "alice@gmail.com", 25);
    Company company = new Company("MyCompany", scott, alice);

    // print company to System.out as xml
    new CompanyInputSource(company).writeTo(System.out, false, 4, null);
}
}}}

Running this prints following:

{{{
<?xml version="1.0" encoding="UTF-8"?>
<company name="MyCompany">
    <employee id="1" age="20">
        <name>scott</name>
        <email>scott@gmail.com</email>
    </employee>
    <employee id="2" age="25">
        <name>alice</name>
        <email>alice@gmail.com</email>
    </employee>
</company>
}}}

`ObjectInputSource` contains several methods to serialize the SAX events:
{{{
public void writeTo(Writer writer, boolean omitXMLDeclaration, int indentAmount) throws TransformerException
public void writeTo(OutputStream out, boolean omitXMLDeclaration, int indentAmount, String encoding) throws TransformerException
public void writeTo(String systemID, boolean omitXMLDeclaration, int indentAmount, String encoding) throws TransformerException
}}}

if `encoding` is null, then it defaults to default XML encoding(`UTF-8`);<br>
These `writeTo(...)` methods use Identity Trasformer;

*NULL Friendly*

The methods to fire SAX events are `null` friendly. it means:
{{{
addAttribute("id", emp.id);
}}}

will not add attribute if `emp.id=null`. So you no longer need to write as below:
{{{
if(emp.id!=null)
    addAttribute("id", emp.id);
}}}

`null` friendly methods, avoid code clutter and make it more readable.

*Method Chaining*

The methods to fire SAX events return `this`. So method calls can be chained to produce more readable code
{{{
startElement("employee")
    .addAttribute("id", emp.id)
    .addAttribute("age", ""+emp.age);
}}}
instead of
{{{
startElement("employee");
addAttribute("id", emp.id);
addAttribute("age", ""+emp.age);
}}}

*Simple Text Only Elements*

You can do following:
{{{
addElement("email", emp.email);
}}}
instead of
{{{
if(emp.email!=null){
    startElement("email");
    addText(emp.email);
    endElement("email");
}
}}}

there is also `addCDATAElement(...)` available

*End Element*

To end element, we do:
{{{
endElement("employee");
}}}

If you mis-spell element name here, it will throw `SAXException`:
    `org.xml.sax.SAXException: expected </employee>`

there is also another variation of `endElement` with no arguments;
{{{
endElement();
}}}
This will implicitly find the recent element started and ends it.

suppose we have:
{{{
endElement("elem3");
endElement("elem2");
endElement("elem1");
}}}
the same can be done in single line as below:
{{{
endElements("elem1");
}}}
This will do endElement() until `elem1` is closed;

To end all elements started, do:
{{{
endElements();
}}}

*NOTE:*

 * `endElements()` will do nothing if all elements are already closed;
 * `endElements()` is implictly called before `writeTo(...)`. So you can safely ignore trailing end elements of xml

*Mark and Release*

{{{
startElement("elem1");
...
startElement("elem2");
....
mark();
startElement("elem3");
....
startElement("elem4");
.....
release(); // will close elem4 and elem3 i.e upto the mark and clears the mark
endElement("elem2");
}}}

release() must be called prior to ending Elements before the mark. i.e,

{{{
startElement("elem1");
...
mark();
....
endElement("elem1"); // will throw SAXException: can't find matching start element
}}}

*NOTE:*

 * You can mark as many times as possible. i.e, multiple marks can exist;<br>
 * endElements() will only end elements which are started after recent mark.
 * `release()` implictly does end elements

you can also release any mark, instead of last mark as below:

{{{
int mark = mark();
...
mark();
...
mark();
...
release(mark);
}}}

when you call `mark()`, it returns the number of mark;<br>
first call to `mark()` returns 1. next call to `mark()` will return 2, if earlier mark is not released;

NOTE:
there is an implicit mark 0, which should not be released by user. it is used by `ObjectInputSource`;

*DTD*
{{{
addSystemDTD("company", "company.dtd");
}}}
will produce<br>

`<!DOCTYPE company SYSTEM "company.dtd">`


{{{
addPublicDTD("company", "-//W3C//DTD XHTML 1.0 Transitional//EN", "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd");
}}}
will produce

`<!DOCTYPE company PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">`

*Adding XML*

{{{
startElement("elem1");
addXML("<test><test1>first</test1><test2>second</test2></test>", false);
endElement();
}}}
will produce:

{{{
<elem1>
    <test>
        <test1>first</test1>
        <test2>second</test2>
    </test>
</elem1>
}}}

The first argument should be well-formed xml string;
second argument will tell whether to ignore root element or not;
when used `true` in above sample it will produce:
{{{
<elem1>
    <test1>first</test1>
    <test2>second</test2>
</elem1>
}}}

there are following other variations of addXML(...) available:
{{{
public ObjectInputSource<E> addXML(InputSource is, boolean excludeRoot) throws SAXException
}}}

for example, you could write:
{{{
addXML(new InputSource("notes.xml"), true);
}}}

*Miscellaneous*
{{{
addComment("this is comment");
addCDATA("this is inside cdata");

// to produce: <?xml-stylesheet href="classic.xsl" type="text/xml"?>
addProcessingInstruction("xml-stylesheet", "href=\"classic.xsl\" type=\"text/xml\"");
}}}

*Namespaces*

{{{
static final String URI_JLIBS = "http://jlibs.org";
static final String URI_COMP = "http://mycompany.com";
static final String URI_EMP = "http://employee.com";

startElement(URI_COMP, "company")
    .addAttribute("name", "mycompany")
    .addAttribute(URI_JLIBS, "version", "0.1")
    .startElement(URI_EMP, "employee")
        .addAttribute("name", "scott")
        .addElement(URI_EMP, "email", "scott@google.com")
        .endElement();
}}}
will produce the following:
{{{
<ns1:company xmlns:ns1="http://mycompany.com" name="mycompany" ns2:version="0.1" xmlns:ns2="http://jlibs.org">
    <ns3:employee xmlns:ns3="http://employee.com" name="scott">
        <ns3:email>scott@google.com</ns3:email>
    </ns3:employee>
</ns1:company>
}}}

You can notice that, we didn't tell what prefix to use.<br>
`ObjectInputSource` is intelligent enough to generate prefixes automatically as ns1, ns2 etc...

*Standard Namespaces*

`jlibs.xml.Namespaces` class contains most frequently used namespaces like:
{{{
public static final String URI_XSD   = "http://www.w3.org/2001/XMLSchema";
public static final String URI_XSI   = "http://www.w3.org/2001/XMLSchema-instance";
public static final String URI_XSL   = "http://www.w3.org/1999/XSL/Transform";
}}}

`Namespaces.suggestPrefix(String uri)` suggests most commonly used prefix for any of these standard prefixes;
{{{
String prefix = Namespaces.suggestPrefix(Namespaces.URI_XSD); // prefix will be "xsd"
}}}

`ObjectInputSource` uses suggested prefixes from `Namespaces` if available; For example:
{{{
import static jlibs.xml.Namespaces.*;

startElement(URI_XSD, "element")
    .addAttribute("name", "employee")
    .addAttribute("type", "employeeType");
}}}
will produce the following:
{{{
<xsd:element xmlns:xsd="http://www.w3.org/2001/XMLSchema" name="employee" type="employeeType"/>
}}}

*Suggesting Prefixes*

{{{
public void suggestPrefix(String prefix, String uri)
}}}

this method can be used to suggest prefix for given uri;<br>
Note that, using this method you can even ovverride the prefixes for standard namespaces, if needed. 

{{{
suggestPrefix(URI_JLIBS, "jlibs");
suggestPrefix(URI_COMP, "comp");
suggestPrefix(URI_EMP, "emp");

startElement(URI_COMP, "company")
    .addAttribute("name", "mycompany")
    .addAttribute(URI_JLIBS, "version", "0.1")
    .startElement(URI_EMP, "employee")
        .addAttribute("name", "scott")
        .addElement(URI_EMP, "email", "scott@google.com")
        .endElement();
}}}
will produce the following:
{{{
<comp:company xmlns:comp="http://mycompany.com" name="mycompany" jlibs:version="0.1" xmlns:jlibs="http://jlibs.org">
    <emp:employee xmlns:emp="http://employee.com" name="scott">
        <emp:email>scott@google.com</emp:email>
    </emp:employee>
</comp:company>
}}}

*Declaring Prefixes*

When you declare prefix, xmlns attribute will be added to generated xml;<br>
This could be handy in following situation:

{{{
startElement(URI_COMP, "company")
    .startElement(URI_EMP, "employee")
        .addAttribute("name", "scott")
        .endElement()
    .startElement(URI_EMP, "employee")
        .addAttribute("name", "alice")
        .endElement()
    .startElement(URI_EMP, "employee")
        .addAttribute("name", "alean")
        .endElement();
}}}
produces the following:
{{{
<ns1:company xmlns:ns1="http://mycompany.com">
    <ns2:employee xmlns:ns2="http://employee.com" name="scott"/>
    <ns2:employee xmlns:ns2="http://employee.com" name="alice"/>
    <ns2:employee xmlns:ns2="http://employee.com" name="alean"/>
</ns1:company>
}}}

In output, you can notice that `ns2` is declared in each `<employee>` element.<br>
The xml is looking cluttered because of this. If we could have defined `ns2` in `<company>`, it would be better.<br>
To do this:
{{{
declarePrefix(URI_EMP);

startElement(URI_COMP, "company")
    .startElement(URI_EMP, "employee")
        .addAttribute("name", "scott")
        .endElement()
    .startElement(URI_EMP, "employee")
        .addAttribute("name", "alice")
        .endElement()
    .startElement(URI_EMP, "employee")
        .addAttribute("name", "alean")
        .endElement();
}}}
now the above code produces:
{{{
<ns2:company xmlns:ns2="http://mycompany.com" xmlns:ns1="http://employee.com">
    <ns1:employee name="scott"/>
    <ns1:employee name="alice"/>
    <ns1:employee name="alean"/>
</ns2:company>
}}}

there is also another variant of `declarePrefix(...)`
{{{
public boolean declarePrefix(String prefix, String uri)
}}}
using this, you can specify prefix of your wish.

*Computing QNames*

{{{
declarePrefix("emp", URI_EMP);

startElement(URI_XSD, "schema");
startElement(URI_XSD, "element")
    .addAttribute("name", "employee")
    .addAttribute("type", toQName(URI_EMP, "emloyeeType"));
}}}
will produce following:
{{{
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:emp="http://employee.com">
    <xsd:element name="employee" type="emp:emloyeeType"/>
</xsd:schema>
}}}

here the value of `@type` is a qname which should be valid. i.e you want to use correct prefix<br>
`toQName(uri, localPart)` will return the correct qname string.<br>
if the given uri is not yet declared, it will be declared automatically.