#summary Using SAX to Sniff XML

[http://code.google.com/p/jlibs/source/browse/trunk/xml/src/jlibs/xml/sax/sniff/XMLDog.java XMLDog] is a dog that is trained to sniff xml documents.

We give set of xpaths to `XMLDog` and ask to sniff some xml document. It uses SAX and with one pass over the document it evaluates all the given xpaths.

Whether it is Xalan/XMLDog, first we need to define `javax.xml.namespace.NamespaceContext`. This interface defines the binding for prefixes to uri.
{{{
import jlibs.xml.DefaultNamespaceContext;
import jlibs.xml.Namespaces;

DefaultNamespaceContext nsContext = new DefaultNamespaceContext(); // an implementation of javax.xml.namespace.NamespaceContext
nsContext.declarePrefix("xsd", Namespaces.URI_XSD);
}}}

Now create an instance of `XMLDOG`, and add the xpaths that need to be evaluated. Note that `XMLDog` can evaluate multiple xpaths in single SAX parse of given xml document.
{{{
import jlibs.xml.sax.sniff.XMLDog;
import jlibs.xml.sax.sniff.XPath;

XMLDog dog = new XMLDog(nsContext);

XPath xpath1 = dog.add("/xs:schema/@targetNamespace");
XPath xpath2 = dog.add("/xs:schema/xs:complexType/@name");
XPath xpath3 = dog.add("/xs:schema/xs:*/@name");
}}}
When you add xpath to `XMLDog`, it returns `XPath` object. This object is the compiled xpath.

you can get the original xpath from `XPath` using `toString()`:
{{{
System.out.println(xpath1); // prints "/xs:schema/@targetNamespace"
}}}

you can ask `XPath` about its result type;
{{{
import javax.xml.namespace.QName;

QName resultType = xpath1.resultType();
System.out.println(resultType); // prints "{http://www.w3.org/1999/XSL/Transform}NODESET"
}}}
The `QName` returned will be one of constants in `javax.xml.xpath.XPathConstants`.

To evaluate given xpaths on some xml document:
{{{
import jlibs.xml.sax.sniff.XPathResults;

XPathResults results = dog.sniff(new InputSource("note.xml"));
}}}

`XPathResults` object will contain the results of all xpath evaluations.

to get result of particular xpath:
{{{
object result = results.getResult(xpath1);
}}}
The return type of `getResult(XPath)` will be `java.lang.Object`;

Depending on the `XPath.resultType()`, this result can be safely cased to a particular type.

Below is the actual result Type for each resultType returned by `XPath`:

|| `XPath.resultType()` || result can be cast to ||
|| `XPathConstants.STRING` || `java.lang.String` ||
|| `XPathConstants.BOOLEAN` || `java.lang.Boolean` ||
|| `XPathConstants.NUMBER` || `java.lang.Double` ||
|| `XPathConstants.NODESET` || `java.util.TreeSet<NodeItem>` ||

For `XPathConstants.NODESET` the `TreeSet` contains `NodeItem`s which are sorted by its document order.

`NodeItem` represens an xml node in xml document; `NodeType` has following properties.

`NodeItem.type`:
    returns type of xml node. will be one of following constants in `NodeItem`:
        COMMENT, PI, DOCUMENT_NODE, ELEMENT, ATTRIBUTE, NAMESPACE, TEXT;
`NodeItem.location`:
    returns unique xpath to the xml node. ex: /xs:schema[1]/xs:complexType[1]/@name<br>
    this can be used to create DOM, in case you need it.

`NodeItem.value`, `NodeItem.localName`, `NodeItem.namespaceURI`, `NodeItem.name`:
    return value/localName/namespaceURI/name of the xml node it represens.

`NodeItem.toString()` simply returns its `location`.

`XPathResults` has handy print method to print results to given `java.io.PrintStream`:
{{{
results.print(System.out);
}}}
will print:
{{{
XPath: /xs:schema/@targetNamespace
      1: /xs:schema[1]/@targetNamespace

XPath: /xs:schema/xs:complexType/@name
      1: /xs:schema[1]/xs:complexType[1]/@name

XPath: /xs:schema/xs:*/@name
      1: /xs:schema[1]/xs:element[1]/@name
      2: /xs:schema[1]/xs:element[2]/@name
      3: /xs:schema[1]/xs:element[3]/@name
      4: /xs:schema[1]/xs:element[4]/@name
      5: /xs:schema[1]/xs:complexType[1]/@name
}}}

*MultiThreading*

`XMLDog` supports multi-hreading. You can add multiple xpaths once, <br>
and sniff multiple documents with same `XMLDog` instance parallely;<br>

*XPath Support:*

`XMLDog` doesn't support complete xpath spec (as of now).

Axises supported are:
 * self axis
 * child axis
 * attribute axis
 * namespace axis
 * descendant axis
 * descendant-or-self axis

Except `id()`, rest of the functions are supported.
it supports predicates and all operators.

`XMLDog` will tell you clearly, if given xpath is not supprted; for example:
{{{
XPath xpath = dog.add("/xs:schema/../@targetNamespace", 1);
}}}
throws following exception:
{{{
java.lang.UnsupportedOperationException: unsupported axis: parent
}}}

This will be very useful. for example you can first try using `XMLDog` and if it throws `UnsupportedOperationException`, then you can fallback to use `DOM`

The XMLDog results conforms to the XPath-Spec. It is coverted by `jlibs.xml.sniff.XPathConformanceTest`

You can look [http://code.google.com/p/jlibs/source/browse/trunk/xpaths.xml here], to see the type of xpaths it has been tested.

*MultiThreading*

`XMLDog` supports multi-hreading. You can add multiple xpaths once, <br>
and sniff multiple documents with same `XMLDog` instance parallely;<br>

*Performance:*

You can find `xmldog.sh/xmldog.bat` in jlibs installation, which can be used to test `XMLDog` perfomace against `Xalan` that is shipped with JDK.<br>
This test reads config from [http://code.google.com/p/jlibs/source/browse/trunk/xpaths.xml xpaths.xml] from jlibs installation.

Here is sample output of this performance test;
{{{
XMLDog: ...............................Done
XALAN:  ...............................Done
Total 1317 xpaths are executed
       jdk time : 2959142000 nanoseconds/2.96 seconds
       dog time : 2700920000 nanoseconds/2.70 seconds
        WINNER : XMLDog (1.10x faster)
    Difference : 258222000 nanoseconds/0.26 seconds 
}}}

It shows that XMLDog is faster than XALAN.

The source code of testcase is [http://code.google.com/p/jlibs/source/browse/trunk/utils/src/jlibs/xml/sax/sniff/XPathPerformanceTest.java here]

*Future:*
 * variable resolution
 * custom functions
 * listening for xpath results. With this you can get results of an xpath as soon as its evaluation is finished. You don't need to wait until all xpaths are evaluated.
 * ability to specify min number of items required in NODESET 

I am looking forward to know, who are interested in `XMLDog`, and why/where you are using. This will give me some boost-up to add more features. Because it takes most of my free time.

Your comments are welcomed;