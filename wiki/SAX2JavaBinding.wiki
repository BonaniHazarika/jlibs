#summary SAX-JAVA Binding Made Easier
#labels SAX,JAVA,BINDING

the package `jlibs.xml.sax.binding` contains classes which help you to read xml and create java objects.

===Concepts===
Before going into details, we will first go through the concepts. Then it will be easier to understand the code.

we have employee.xml:
{{{
<employee>                     
    <name>scott</name>         
    <age>20</age>              
    <experience>5</experience> 
</employee>
}}}
and Employee class:
{{{
public class Employee{
    private String name;
    private int age;
    private int experience;

    // getter and setter methods
}
}}}

Each element in xml will create a java object.
Let us see the java objects created for above xml:
{{{
        XML                     |     Java Object  
--------------------------------|-----------------
<employee>                      |   new Employee()
    <name>scott</name>          |   new String(#text) 
    <age>20</age>               |   new String(#text) 
    <experience>5</experience>  |   new String(#text) 
</employee>                     |
}}}
From above table you can see that:
 * `<employe/>` element create new `Employee` object<br>
 * `<name/>`, `<age/>` and `<experience/>` elements create `String` objects with their text content(i.e `#text`)

Now we have 4 java Objects ( one `Employee` object and four `String` objects)

Now *relation* comes into picture. Each element has a relation which tells how to relate current element's java object with parent element's java oject.

{{{
        XML                     |     Java Object             |   Relation
--------------------------------|--------------------------------------------------------
<employee>                      |   emp = new Employee()      |   - No Relation -
    <name>scott</name>          |   name = new String(#text)  | emp.setName(name)
    <age>20</age>               |   age = new String(#text)   | emp.setAge(age)
    <experience>5</experience>  |   exp = new String(#text)   | emp.setExperience(exp)
</employee>                     |
}}}

The above table shows how java objects created are related with each other.<br>
To make understanding easier, we assigned each java object created into some variable.
 * `Employee` object created is assigned to `emp` variable
 * `String` created for `<name>` element is assigned to `name` variable
 * `String` created for `<age>` element is assigned to `age` variable
 * `String` created for `<experience>` element is assigned to `exp` variable

Now you can see that relation of `<name>` element and its parent element `<employee>` in java is:
{{{
emp.setName(name)
}}}
Once Java-Object and Relation are defined for each element type, It is piece of cake to read xml document into java objects.
------------------------------------------------------------------------------------------------------------------------------

===Implementing Binding===
{{{
import jlibs.xml.sax.binding.*;

@Binding("employee")
public class EmployeeBinding{
    @Binding.Start
    public static Employee onStart() throws SAXException{
        return new Employee();
    }

    @Binding.Text({"name", "age", "experience"})
    public static String onText(String text){
        return text;
    }

    @Relation.Finish("name")
    public static void relateName(Employee employee, String name){
        employee.setName(name);
    }

    @Relation.Finish("age")
    public static void relateAge(Employee employee, String age){
        employee.setAge(Integer.parseInt(age));
    }

    @Relation.Finish("experience")
    public static void relateExperience(Employee employee, String experience){
        employee.setExperience(Integer.parseInt(experience));
    }
}
}}}

Let us walk through the code:

{{{
import jlibs.xml.sax.binding.*;
}}}
package `jlibs.xml.sax.binding` contains various annotations, which we use to define binding.

{{{
@Binding("employee")
public class EmployeeBinding{
}}}
`@Binding("employee")` annotation says that, `EmployeeBinding` class defines binding for `<employee>` element

{{{
@Binding.Start
public static Employee onStart() throws SAXException{
    return new Employee();
}
}}}
`@Binding.Start` annotation says that, when `<employee>` element starts call this method.<br>
this method returns new `Employee` object. i.e for each `<employee>` we create an `Employee` object.

{{{
@Binding.Text({"name", "age", "experience"})
public static String onText(String text){
    return text;
}
}}}
`@Binding.Text({"name", "age", "experience"})` annotation says that, call this method for `<name>`, `<age>` and `<employee>` text content.<br>
The argument `text` will be the text content of that element. The java object created for these elements is their text
content, so we simply return the `text` argument.

{{{
@Relation.Finish(name")
public static void relateName(Employee employee, String name){
    employee.setName(name);
}
}}}
`@Relation.Finish("name")` annotation says that, call this method on `<name>` element end.<br>
The first argument will be the java object created for `<name>`'s parent element (i,e `<employee>` element), which is `Employee` object created by `onStart()` method.<br>
The second argument will be the java object created for `<name>` element, which is `String` object created by `onText(...)` method.

similarly `relateAge(...)` and `relateExperience(...)` are called on `<age>` and `<experience>` element end respectively.
------------------------------------------------------------------------------------------------------------------------------

===SAX Parsing===
Now we have finished coding `EmployeeBinding`. Now let us see how to read employee xml document using this binding.
{{{
public static Employee read(File xmlFile) throws Exception{
    BindingHandler handler = new BindingHandler(EmployeeBinding.class);
    return (Employee)handler.parse(new InputSource(xmlFile.getPath()));
}
}}}

`BindingHandler` is an implementation of SAX `DefaultHandler`. It's constructor takes the binding calss as argument.
------------------------------------------------------------------------------------------------------------------------------

===Behind the Scene===

Let us see what happens behind the scene.

All the annoations we have used have `RetentionPolicy.SOURCE`(except `@Binding`). i.e These annotations are not available at runtime.<br>
`JLibs` comes with an [http://code.google.com/p/jlibs/source/browse/trunk/xml/src/jlibs/xml/sax/binding/impl/processor/BindingAnnotationProcessor.java annotation processor], 
which processes these annotations at compile time.<br>
This processor generates a class for each class with `@Binding` annotation.<br>
This generated class defines the [http://en.wikipedia.org/wiki/State_diagram state diagram] for the binding.

for example when you compile `EmployeeBinding` class, you will get an additional class `EmployeeBindingImpl` generated.

`BindingHandler` is a SAX `DefaultHandler` which implements a [http://en.wikipedia.org/wiki/Finite-state_machine state machine].

Because reflection is not used at runtime, the sax parsing will be faster.
------------------------------------------------------------------------------------------------------------------------------
===Unexpected Elements=====

let us say employee.xml is:
{{{
<employee>                     
    <name>scott</name>         
    <age>20</age>              
    <experience>5</experience> 
    <email>scott@email.com</email> 
</employee>
}}}
The above xml document has an unexpected element `<email>` for which we have not defined any binding.

When you read the above xml document using `EmployeeBinding`, it simply ignores the undefinded element `<email>`.<br>
i.e you will be able to create `Employee` object from the above xml document without any errors.

Suppose you want to issue an error for undefined elements then do:
{{{
handler.setIgnoreUnresolved(false); // default is true
}}}

now when you try to read the above xml document, you will get following exception:
{{{
org.xml.sax.SAXException: can't find binding for /employee/email (line=5, col=12)
}}}
------------------------------------------------------------------------------------------------------------------------------
===Reusing Bindings===

Have a look at `Company` class:
{{{
public class Company{
    private String name;
    private Employee manager;
    public List<Employee> employees = new ArrayList<Employee>();
    
    // getter and setter methods
}
}}}

and company.xml as below:
{{{
        XML                        |     Java Object                   |   Relation
-----------------------------------|-------------------------------------------------------------------
<company name="foo">               | company = new Company(@name)      |
    <manager>                      | manager = /*use EmployeeBinding*/ |
        <name>admin</name>         |                                   |
        <age>30</age>              |                                   |
        <experience>7</experience> |                                   |
    </manager>                     |                                   | company.setManager(manager)
    <employee>                     | employee = /*use EmployeeBinding*/|
        <name>scott</name>         |                                   |
        <age>20</age>              |                                   |
        <experience>5</experience> |                                   |
    </employee>                    |                                   | company.addEmployee(employee)
    <employee>                     | employee = /*use EmployeeBinding*/|
        <name>alice</name>         |                                   |
        <age>21</age>              |                                   |
        <experience>4</experience> |                                   |
    </employee>                    |                                   | company.addEmployee(employee)
</company>                         |                                   |
}}}

on `<company>` element begin, we create `Company` object.<br>
for `<manager>` and `<employee>` elements we will create `Employee` objects, using `EmployeeBinding` coded earlier.<br>
on `<manager>` element end, we relate `company` and `manager` objects using `setManager(...)` method<br>
on `<employee>` element end, we relate `company` and `employee` objects using `addEmployee(...)` method

Let us implmennt `CompanyBinding`:
{{{
@Binding("company")
public class CompanyBinding{
    @Binding.Start
    public static Company onStart(Attributes attributes) throws SAXException{
        return new Company(attributes.getValue("name"));
    }

    @Binding.Element(element = "manager", clazz = EmployeeBinding.class)
    public static void onManager(){}

    @Relation.Finish("manager")
    public static void relateManager(Company company, Employee manager){
        company.setManager(manager);
    }

    @Binding.Element(element = "employee", clazz = EmployeeBinding.class)
    public static void onEmployee(){}

    @Relation.Finish("employee")
    public static void relateEmployee(Company company, Employee employee){
        company.employees.add(employee);
    }
}
}}}
Let us walk through the code:
{{{
@Binding.Element(element = "manager", clazz = EmployeeBinding.class)
public static void onManager(){}
}}}
`@Binding.Element(element = "manager", clazz = EmployeeBinding.class)` annotation says to reuse `EmployeeBinding` for `<manager>` element.

------------------------------------------------------------------------------------------------------------------------------
===When no-arg constructor is missing===

Let us say our `Employee` has no default constructor:
{{{
public class Employee{
    private String name;
    private int age;
    private int experience;

    public Employee(String name, int age, int experience){
        this.name = name;
        this.age = age;
        this.experience = experience;
    }

    // getter methods
}
}}}
Let us see how to handle this situation:
{{{
        XML                     |     Java Object                                                     |   Relation
--------------------------------|---------------------------------------------------------------------|----------------------------
<employee>                      |                                                                     |
    <name>scott</name>          | name = new String(#text)                                            | parent[<name>] = name
    <age>20</age>               | age = new String(#text)                                             | parent[<age>] = age
    <experience>5</experience>  | exp = new String(#text)                                             | parent[<experience>] = exp
</employee>                     | emp = new Employee(current[<name>], current[<age>], [<experience>]) | 
}}}

Notice that now we are creating `Employee` object in `<employee>` element end, rather than `<employee>` element begin.<br>
This is because, we know the values of name, age and experience are available only on `<employee>` element end.<br>

Earlier, the relation for `<name>`, `<age>` and `<experience>` used to call respective set method on `Employee` object.<br>
Now we can't do that, because we don't have `Employee` created by that time.

For each element in xml document, a [http://code.google.com/p/jlibs/source/browse/trunk/xml/src/jlibs/xml/sax/binding/SAXContext.java SAXContext] is maintained by `BindingHandler`.<br>
This context is used to store the java object you created for that element.<br>
`SAXContext.object` gives the object you have created. 

Other than that, `SAXContext` also has map, which you can use to store values temporarly which are required to create the java object later.<br>
`SAXContext.temp` is that map. here key is `QName` and value is any `Object`.

let us see the relation for `<name>` element:
{{{
parent[<name>] = name
}}}
here `parent` refers to parent element's (i,e `<employee>`) context;<br>
we are storing the `String` object created for `<name>` element, in `<employee>`'s context.<br>
here the key used is the qname name of current element i.e `<name>`

similarly we are saving the values of `<age>` and `<experience>` elements also in `<employees>`'s context.

now on `<employee>` element end we do:
{{{
emp = new Employee(current[<name>], current[<age>], [<experience>])
}}}
here `current` refers to current element's (i.e `<employee>`) context;<br>
we are retriving the values of `<name>`, `<age>` and `<experience>` stored earlier, and creating `Employee` object using them.

Let us see what it looks like in java code:
{{{
@Binding("employee")
public class EmployeeBinding{
    @Binding.Text({"name", "age", "experience"})
    public static String onText(String text){
        return text;
    }

    @Relation.Finish({"name", "age", "experience"})
    public static void relateWithEmployee(SAXContext<Employee> parent, SAXContext<String> current){
        parent.put(current.element(), current.object);
    }

    @Binding.Finish
    public static Employee onFinish(SAXContext<Employee> current) throws SAXException{
        String name = current.get(new QName("name"));
        String age = current.get(new QName("age"), "0");
        String experience = current.get(new QName("experience"), "0");
        return new Employee(name, Integer.parseInt(age), Integer.parseInt(experience));
    }
}
}}}
Let us walk through the code;
{{{
@Relation.Finish({"name", "age", "experience"})
public static void relateWithEmployee(SAXContext<Employee> parent, SAXContext<String> current){
    parent.put(current.element(), current.object);
}
}}}
`@Relation.Finish({"name", "age", "experience"})` annotation says that, call this method on<br>
`<name>`, `<age>` and `<experience>` element end.<br>
the first argument `SAXContext<Employee> parent` is the context of parent element i.e `<employee>`<br>
the second argument `SAXContext<String> current` is the context of current element i.e `<name>` or `<age>` or `<experience>`<br>
`current.element()` gives `QName` of current element.<br>
`current.object` gives the `String` object we have created for the current element<br>
`parent.put(...)` saves the value the `SAXContext.temp`.<br>

Here we used `parent.put(...)` rather than `parent.temp.put(...)`
this is because `SAXContext.temp` is null initially and need to be initiazed before use.<br>
This is to avoid unncessary map creation. <br>
`SAXContext` provides some handy methods to access `temp` like `put(...)`, `get(...)`.
These methods take care of initializing `temp` lazily when requried.

{{{
@Binding.Finish
public static Employee onFinish(SAXContext<Employee> current) throws SAXException{
    String name = current.get(new QName("name"));
    String age = current.get(new QName("age"), "0");
    String experience = current.get(new QName("experience"), "0");
    return new Employee(name, Integer.parseInt(age), Integer.parseInt(experience));
}
}}}
`@Binding.Finish` annotation says that, call this method on `<employee>` element end.<br>
the argument `SAXContext<Employee> current` is the context of current element i.e `<employee>`<br>
here we are retriving values of name, age and experience of current context using `SAXContext.get(...)` method.<br>
The first argument to `get(...)` is the `QName` whose value you want to retrieve.<br>
The second argument to `get(...)` is the default value to be returned when no value is present in `temp`.<br>
the second argument to `get(...)` is optional.

------------------------------------------------------------------------------------------------------------------------------

I will be preparing more example use cases like:
 * recursive bindings
 * etc

Your comments are appreciated.