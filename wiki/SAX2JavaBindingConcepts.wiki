#summary SAX-JAVA Binding Concepts
#labels SAX,JAVA,BINDING

the package `jlibs.xml.sax.binding` contains classes which help you to read xml and create java objects.

Before going into details, we will first go through the concepts. Then it will be easier to understand the code.

we have employee.xml:
{{{
<employee>                     
    <name>scott</name>         
    <age>20</age>              
    <experience>5</experience> 
</employee>
}}}
and Employee class:
{{{
public class Employee{
    private String name;
    private int age;
    private int experience;

    // getter and setter methods
}
}}}

Each element in xml will create a java object. We call this as *binding*.<br>
Let us see the java objects created for above xml:
{{{
        XML                     |     (Binding)Java Object  
--------------------------------|-----------------
<employee>                      |   new Employee()
    <name>scott</name>          |   new String(#text) 
    <age>20</age>               |   new String(#text) 
    <experience>5</experience>  |   new String(#text) 
</employee>                     |
}}}
From above table you can see that:
 * `<employe/>` element create new `Employee` object<br>
 * `<name/>`, `<age/>` and `<experience/>` elements create `String` objects with their text content(i.e `#text`)

How to create java object from xml element is defined by `jlibs.xml.sax.binding.Binding` class.<br>
We will look into more details of coding `Binding` later.

Now we have 4 java Objects ( one `Employee` object and four `String` objects)

Now *relation* comes into picture. Each element has a relation which tells how to relate current element's java object with parent element's java oject.

{{{
        XML                     |     (Binding)Java Object    |   Relation
--------------------------------|--------------------------------------------------------
<employee>                      |   emp = new Employee()      |   - No Relation -
    <name>scott</name>          |   name = new String(#text)  | $emp.setName($name)
    <age>20</age>               |   age = new String(#text)   | $emp.setAge($age)
    <experience>5</experience>  |   exp = new String(#text)   | $emp.setExperience($exp)
</employee>                     |
}}}

The above table shows how java objects created are related with each other.<br>
To make understanding easier, we assigned each java object created into some variable.
 * `Employee` object created is assigned to `emp` variable
 * `String` created for `<name>` element is assigned to `name` variable
 * `String` created for `<age>` element is assigned to `age` variable
 * `String` created for `<experience>` element is assigned to `exp` variable

Now you can see that relation of `<name>` element and its parent element `<employee>` in java is:
{{{
$emp.setName($name)
}}}

This relationship between java objects is captured by `jlibs.xml.sax.binding.Relation` class.<br>
We will look into more details of coding `Relation` later.

Once Binding and Relation are defined for each element type, It is piece of cake to read xml document into java objects.

===SAXContext===

Bindings create java Objects for the elements and Relations chain these java objects.<br>
Where are those java objects stored and how they are accessed in `Relation` ? the answer is `SAXContext`.

Each element in xml has an associated `SAXContext` instance. Bindings have access to the current `SAXContext`.<br>
They store the java object created in current context i.e, `SAXContext.object`.

Similarly `Relation`s have access to the current `SAXContext` and parent `SAXContext`. `Relation` can access parent element's<br>
java object and current element's java object from these contexts and chain them.

[http://code.google.com/p/jlibs/source/browse/trunk/xml/src/jlibs/xml/sax/binding/SAXContext.java SAXContext source]

===Bindings===

Let us create Bindings for this example.

{{{
import jlibs.xml.sax.binding.*;

public class EmployeeBinding extends Binding<Employee>{
    @Override
    public void start(SAXContext<Employee> current, Attributes attributes) throws SAXException{
        current.object = new Employee();
    }
}
}}}

We created a subclass of `Binding` named `EmployeeBinding`.<br>
Our binding creates `Employee` object, so we are extending `Binding<Employee>`.<br>

`Binding` has three methods: ([http://code.google.com/p/jlibs/source/browse/trunk/xml/src/jlibs/xml/sax/binding/Binding.java source])
 * `start(...)` method is called on `<employee>` element begin
 * `text(...)` method is called when text content is encountered in `<employee>` element
 * `finish(...)` method is called on `<employee>` element end

We are overriding `start(...)` method. In this method we are creating an `Employee` object and storing it in `current` context.

Let us create bindings for `<name>`, `<age>` and `<experience>` elements.<br>
For all these elements, the java object created is a `String` containing the content of that element.<br>
Because for all these elements we are doing samething, we can create single binding and reuse it.

{{{
import jlibs.xml.sax.binding.*;

public class TextBinding extends Binding<String>{
    @Override
    public void text(SAXContext<String> current, String text){
        current.object = text;
    }
}
}}}
Notice that we are extending `Binding<String>`.<br>
Here we are overriding `text(...)` method. This method is called when text is encountered.<br>
The complete text content is passed as second argument.<br>
We are simply storing this `text` argument in current context.

Because the above binding is so frequently required, JLibs already comes with `TextBinding.INSTANCE`.<br>
i.e You can use `TextBinding.INSTANCE` rather than creating `TextBinding` class yourself.

[http://code.google.com/p/jlibs/source/browse/trunk/xml/src/jlibs/xml/sax/binding/TextBinding.java TextBinding source]

===Relations===

We have to implement three relations, one each for `<name>`, `<age>` and `<experience>`.

Let us implement relation for `<name>` element.
{{{
import jlibs.xml.sax.binding.*;

new Relation<Employee, String>(){
    @Override
    public void finished(SAXContext<Employee> parent, SAXContext<String> current){
        parent.object.setName(current.object);
    }
}
}}}
Here we are creating an anonymous calss extending `Relation<Employee, String>`.<br>
`<Employee, String>` says that, this relation expects `Employee` object in parent context and `String` object in current context.<br>

`Relation` has two methods: ([http://code.google.com/p/jlibs/source/browse/trunk/xml/src/jlibs/xml/sax/binding/Relation.java source])
 * `started(...)` method is called on `<name>` element begin
 * `finished(...)` method is called on `<name>` element end

Here we are overriding `finished(...)` but not `stared(...)`. This is because the `String` object <br>
for `<name>` element is not yet created on `<name>` element begin.

Similarly we can create `Relation` implementations for `<age>` and `<experience>`.

===BindingRegistry===

Each `Binding` should know about its child element bindings and the relations. We specify this in `EmployeeBinding` constructor:
{{{
public class EmployeeBinding extends Binding<Employee>{
    public static final QName QNAME_NAME = new QName("name");
    public static final QName QNAME_AGE = new QName("age");
    public static final QName QNAME_EXPERIENCE = new QName("experience");

    public EmployeeBinding(){
        // for <name> element
        registry.register(QNAME_NAME, TextBinding.INSTANCE, new Relation<Employee, String>(){
            @Override
            public void finished(SAXContext<Employee> parent, SAXContext<String> current){
                parent.object.setName(current.object);
            }
        });

        //for <age> element
        registry.register(QNAME_AGE, TextBinding.INSTANCE, new Relation<Employee, String>(){
            @Override
            public void finished(SAXContext<Employee> parent, SAXContext<String> current){
                parent.object.setAge(Integer.parseInt(current.object));
            }
        });

        //for <experience> element
        registry.register(QNAME_EXPERIENCE, TextBinding.INSTANCE, new Relation<Employee, String>(){
            @Override
            public void finished(SAXContext<Employee> parent, SAXContext<String> current){
                parent.object.setExperience(Integer.parseInt(current.object));
            }
        });
    }
    
    ...
}}}

`Binding` has a `registry` which maintains binding and relation for each possible child element.<br>
We register binding and relation for each child element as follows:
{{{
registry.register(qname, binding, relation);
}}}

Now the last step is, How to use `EmployeeBinding` to read xml file.
{{{
BindingRegistry<?> registry = new BindingRegistry();
registry.register(new QName("employee"), new EmployeeBinding()); // use EmployeeBinding for <employee> element

BindingHandler handler = new BindingHandler(registry);
Employee emp = (Employee)handler.parse(new InputSource("employee.xml"));
}}}

We create `BindingRegistry` instance and register bindings for all possible root elements.<br>
Next we use `BindingHandler` to do sax parsing using this registry.

[http://code.google.com/p/jlibs/source/browse/trunk/xml/src/jlibs/xml/sax/binding/BindingRegistry.java BindingRegistry source]<br>
[http://code.google.com/p/jlibs/source/browse/trunk/xml/src/jlibs/xml/sax/binding/BindingHandler.java BindingHandler source]

===Summary====

Pseudo code for employee binding:
{{{
        XML                     |     (Binding)Java Object              |   Relation
--------------------------------|-------------------------------------------------------------------------------------
<employee>                      |   current.object = new Employee()     |   - No Relation -
    <name>scott</name>          |   current.object = new String(#text)  | parent.object.setName(current.object)
    <age>20</age>               |   current.object = new String(#text)  | parent.object.setAge(current.object)
    <experience>5</experience>  |   current.object = new String(#text)  | parent.object.setExperience(current.object)
</employee>                     |
}}}

Here `current` refers to current `SAXContext` and `parent` refers to parent `SAXContext`.

Java code:
{{{
import jlibs.xml.sax.binding.*;
import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.namespace.QName;
import java.io.InputStream;

/**
 * @author Santhosh Kumar T
 */
public class EmployeeBinding extends Binding<Employee>{
    public static final QName QNAME_NAME = new QName("name");
    public static final QName QNAME_AGE = new QName("age");
    public static final QName QNAME_EXPERIENCE = new QName("experience");

    public EmployeeBinding(){
        // for <name> element
        registry.register(QNAME_NAME, TextBinding.INSTANCE, new Relation<Employee, String>(){
            @Override
            public void finished(SAXContext<Employee> parent, SAXContext<String> current){
                parent.object.setName(current.object);
            }
        });

        //for <age> element
        registry.register(QNAME_AGE, TextBinding.INSTANCE, new Relation<Employee, String>(){
            @Override
            public void finished(SAXContext<Employee> parent, SAXContext<String> current){
                parent.object.setAge(Integer.parseInt(current.object));
            }
        });

        //for <experience> element
        registry.register(QNAME_EXPERIENCE, TextBinding.INSTANCE, new Relation<Employee, String>(){
            @Override
            public void finished(SAXContext<Employee> parent, SAXContext<String> current){
                parent.object.setExperience(Integer.parseInt(current.object));
            }
        });
    }

    // <employee> ==> current = new Employee();
    @Override
    public void start(SAXContext<Employee> current, Attributes attributes) throws SAXException{
        current.object = new Employee();
    }

    public static void main(String[] args) throws Exception{
        BindingRegistry<?> registry = new BindingRegistry();
        registry.register(new QName("employee"), new EmployeeBinding());
        BindingHandler handler = new BindingHandler(registry);
        Employee emp = (Employee)handler.parse(new InputSource(args[0]));
        System.out.println(emp);
    }
}
}}}

Binding instances are reusable. i.e one instanceof binding is enough to parse multipe documents in multiple threads
Binding instances should not use any instance specific information. all methods in Binding are treated to be static i.e shouldn't access any instance data

The java code looks verbose compared to pseudo code because of anonymous classes otherwize the code is pretty concise.

Your comments are appreciated.